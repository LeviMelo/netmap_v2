#!/usr/bin/env bash
# gpatch: paste-and-apply a unified diff safely, with subdir detection
set -euo pipefail

tmp="$(mktemp -t gpatch.XXXXXX)"
cat > "$tmp"
size=$(wc -c <"$tmp" | tr -d ' ')
if [ "$size" -eq 0 ]; then
  echo "!! Empty patch on stdin. Temp: $tmp" >&2
  exit 2
fi

# repo info
if ! root="$(git rev-parse --show-toplevel 2>/dev/null)"; then
  echo "!! Not inside a git repo. Temp: $tmp" >&2
  exit 2
fi
prefix="$(git rev-parse --show-prefix 2>/dev/null || true)"  # may be empty

echo "== gpatch: received $size bytes; temp=$tmp"
echo "== dry-run (git apply --check)…"
if ! git apply --check "$tmp" 2>/dev/null; then
  echo "!! Dry-run failed. Leaving patch at: $tmp" >&2
  exit 3
fi

applied=0

echo "== apply attempt 1 (plain)…"
if git apply --whitespace=fix "$tmp" 2>/dev/null; then
  applied=1
else
  echo "!! apply attempt 1 failed (plain)."
fi

if [ "$applied" -eq 0 ] && [ -n "$prefix" ]; then
  echo "== retry with --directory=$prefix"
  if git apply --whitespace=fix --directory="$prefix" "$tmp" 2>/dev/null; then
    applied=1
  else
    echo "!! apply attempt 2 failed (with --directory=$prefix)."
  fi
fi

if [ "$applied" -eq 0 ]; then
  echo "!! No changes applied. See: $tmp" >&2
  exit 4
fi

# Sanity: after a real apply, the same patch should no longer pass --check
if git apply --check "$tmp" 2>/dev/null; then
  echo "!! Patch still appears applicable (likely no-op or path mismatch). See: $tmp" >&2
  exit 5
fi

echo "== applied OK."
rm -f "$tmp"

